\documentclass[a4paper, fleqn]{article}

\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath, mathtools}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 1}}

\author{Καζγκούτης Αθανάσιος \and
	    Charbel Al Haddad \and 
	    Παπαδόπουλος Δημήτριος-Λάζαρος
}

\date{March 24, 2023}

\begin{document}

\maketitle
\pagebreak
\section*{Πρόβλημα 1}

\textbf{
\color{red}Ερώτημα 1}
O αλγόριθμος που παρατιίθεται παρακάτω δέχεται σαν είσοδο μια συστοιχία n στοιχίων όπου n ειναι οι ψήφοι -σε ονοματεπώνυμα-μιας κοινότητας.
Στόχος του αλγόριθμου ειναι:
\begin{enumerate}
    \item να ελέγξει ποιος/α έχει τους περισσότερους ψήφους.
    \item αμα ξεπερνούν ή είναι ίσοι του 50\%\ των συνολικών ψήφων.
    \item εφόσων ισχύει το παραπάνω επιστρέψει στην έξοδο το ονοματεπώνυμο του υποψήφιου(ελέγχοντας το ακραίο σεναρίο να υπάρχουν 2 υποψήφιοι που ισοβαθμούν ΚΑΙ έχουν το 50\%\ των ψήφων) .
  
\end{enumerate}
        $$ \textbf{ΑΛΓΟΡΙΘΜΟΣ 1}$$


\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}

\begin{lstlisting}[mathescape]
function MajorityFinder(A[1...n])
 majority_person = [array of 2 elements]
 maxcount = 0
 count
 temp
 for(i = 1 to n)
 	count = 0
 	temp = A[i]
 	for(j = 1 to n)
 		if(temp = = A[j])
 			count++
 	if(count > maxcount)
 		maxcount = count
 		majority_person[1] = temp
 		majority_person[2] = null
 	else if((count = = maxcount) AND (temp $\neq$ majority_person[1]))
 		majority_person[2] = temp
 if(maxcount $\geq$ $\lceil\frac{n}{2}\rceil$)
 	return majority_person
 else 
 	return "no person has the majority"
\end{lstlisting}
\textit{
\section*{
\subsection*{ΑΝΑΛΥΣΗ ΑΛΓΓΟΡΙΘΜΟΥ:}}
}

\begin{itemize}
    \item Στη $1^η$ σείρα ο αλγόριθμος δέχεται τις n ψήφους μέσω μιας συστοιχίας "A[1...n]"

    \item Στη $2^η$ σειρα ορίζουμε τον πίνακα "majority\_person" στον οποίο θα αποθηκευτεί  το ονόμα του υπερέχoντα υποψήφιου , το μέγεθος του πίνακα έχει 2 θέσεις για να καλύπτει και την περίπτωση που 2 υποψήφιοι συγκεντρώνουν από 50\% ο καθένας.

    \item Στις γραμμές 3-5 γίνονται αρχικοποιήσεις που χρησιμέυουν στη καταμέτρηση των ψήφων και των υποψήφιων με τους περισσότερους.

    \item Στις γραμμές 6-11 ο αλγόριθμος καταμετρεί όλες τις ψήφους .Συγκεκριμένα η αρχική η for χρησιμοποιείται για να προσπελαστούν όλες οι ψήφοι,ενώ η 2η για να γίνει έλεγχος ποιες ψηφοί έχουν το ίδιο ονοματεπώνυμο με την i-στη.Ετσι μεσω το count μετράμε τις συνολικες ψήφους που έχει ο υποψήφιος που βρισκεταιο στην i-στη θεση του αρχικου πινακα ενώ στο temp αποθηκέυται το ονοματεπώνυμο του.Eπειδη εχουμε εμφωλευμενες for η πολυπολοκοτητα γινεται Ο($n^2$).   

    \item Στις γραμμες 12-17 γίνεται  ελεγχός για να βρέθει  ποιος υποψήφιος εχει τις περισσοτερες ψήφους,ενω καλυπτεται η περιπτωση της ισοβαθμιας υποψηφιων μεσω του μεταβλητου πινακα "majority person"

    \item Στις τελευταιες γραμμες 18-21 γινεται ελεγχος αμα καποιος υποψήφιος εχει $\geq$ του 50\%\ των ψηφών,η εξοδος ειτε θα εχει κανενα ενα ή ακομα και 2 ομνοματα στην ακραια περίπτωση που έχουμε 2 υποψηφιους με τις μισε ψηφους αμφοτεροι.

    \item Aνακεφαλαιώνοντας πρόκειται για εναν αργο αλγορίθμο Ο($n^2$) καθως ελεγχονται n φορες όλα τα ονοματεπώνυμα ενώ συγκρίνουμε ολές τις ψήφους μεταξύ τους μια προς μια .Γεγονώς που θα προσπαθήσουμε να ανατρέψουμε στα επώμενα ερωτήματα   
\end{itemize}
\newpage

\textbf{
\color{red}Ερώτημα 2}
Στη προσπάθεια μας να βελτιώσουμε τον αλγόριθμο πολυπλoκότητας από 0($n^2$) σε 0($logn$) θα χρησιμοποιήσουμε την στρατιγική \textit{\textbf{διαίρει-και-κυρίευε}}(Divide-and-conquer).Συγκεκριμένα ο αλγόριθμος  μας βασίζεται στην συγχωνευτική ταξινόμιση (merge sort) ,ωστε να ταξινομηθουν τα ονοματεπώνυμα σε μια σειρά(στη περίπτωση μας αλφαβητικά).Τελός έχωντας μια ταξινομημένη λίστα μπορούμε πολυ ευκόλα να ελέγξουμε αν υπάρχει υποψήφιος με τουλάχιστον 50\%\ των ψήφων όπως παρουσιάζεται  αναλυτικότερα παρακάτω. 



         \title{ο βοηθητικός αλγοριθμος που θα χρησιμοποιήσουμε:}
         


\lstset{frame=none}

\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Merge Sort}]
\begin{lstlisting}[mathescape]
function mergesort(a[1...n])
 if(n > 1)
 	return merge(mergesort(a[1...$\lfloor\frac{n}{2}\rfloor$]), mergesort(a[$\lfloor\frac{n}{2}\rfloor$ + 1 ...n]))
 else
 	return a
\end{lstlisting}

\begin{lstlisting}[mathescape]
function merge(x[1...k], y[1...l])
 if(k = 0)
 	return y[1...l]
 if(l = 0)
 	return x[1...l]
 if(x[1] $\geq$ y[1])
 	return x[1] $\circ$ merge(x[2...k], y[1...l])
 else
 	return y[1] $\circ$ merge(x[1...k], y[2...l])
\end{lstlisting}
\end{tcolorbox}

\subsection*{Ανάλυση merge sort για την περίπτωηση μας:}
\begin{itemize}
    \item \textbf{Αναδρομή}:διαιρούμε το πρόβλημα μας στη μέση $\frac{n}{2}$ διαδοχικά(a=2,b=2),η αναδρομή εξαντλείτε  οταν η ταξινομητέα ακολουθία έχει μήκος 1 $\geq$n, δηλαδή εχεί μονο μια ψήφο με ονοματεπώνυμο που ειναι ήδη ταξινομιμένη . 
\end{itemize}
    \begin{itemize}
        \item \textbf{Συγχώνευση(merge)}:η συνάρτηση αυτή συγχωνέυει ταξινομόντας 2 ήδη ταξινομημένους πίνακες ,το βασίκο βήμα της συνάστησης εκτελείτε το πολύ n φορές ενω το υπολογιστικό κοστός c ειναι στη χειρότερη περίπτωση  ίσο με το χρόνο που χρειάζεται να προσπελαστή ένα ονοματεπώνυμο ,αυτό συμβαίνει οταν έχουμε να συγκρίνουμε το ίδιο όνομα δηλαδή την ίδια ψήφο .Συγκεκρίμενα  πάλι θεώρουμε ότι το μήκος του έχει ενα λογικό εύρος και το c είναι απλα ένας πεπερασμένος αριθμός.Σε κάθε άλλη κατάσταση άν ο πρώτος χαρακτήρας από την πρώτη συμβολοσειρά είναι μεγαλύτερος (ή μικρότερος) από αυτόν της άλλης συμβολοσειράς, τότε η πρώτη συμβολοσειρά είναι μεγαλύτερη (ή μικρότερη) από τη δεύτερη.Σύμφωνα με τα παραπάνω η συνάρτηση merge έχει χρόνο εκτέλεσης \textbf{Θ(n)}.
    \end{itemize}
     \begin{itemize}
         \item \textbf{Συνολικός χρόνος} :Οπως  γνωρίζουμε απο την θεωρία (master theory) για a=2,b=2  $$Τ(n)=2T(\frac{n}{2})+Θ(n)=cnlogn+cn$$ αρα θα έχουμε χρόνο εκτέλεσης Θ(nlogn).
     \end{itemize}
\newpage
\begin{itemize}
    \item  παρακάτω παρουσιάζεται ο  βασικός αλγόριθμος του ερωτήματος 2 : 
             
\end{itemize}

          $$ \textbf{ΑΛΓΟΡΙΘΜΟΣ 2}$$

\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}


%θυμησου να πεις οτι ο πινακας ξεκιναει απο το 1 και οχι απο το 0
\begin{lstlisting}[mathescape]
function MajorityFinder2(A[1...n])
 mergesort(A)
 for(i = 1 to n){
     if((n mod 2 == 1) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$ - 1 + i)))		
                return A[i] //end algorithm
      if ((n mod 2 == 0) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$  + i)))
                 return A[i]//end algorithm
 }
 return no majority person found
 
  
\end{lstlisting}
\paragraph{    ΑΝΑΛΥΣΗ ΑΛΓΟΡΙΘΜΟΥ}
\begin{itemize}
    \item Στη πρωτη σειρα ο πίνακας Α δέχεται τους ψηφούς σε ονοματεπώνυμα (συμβολοσειρές).
\end{itemize}
\begin{itemize}
    \item Στη 2η γραμμή καλούμε την συνάρτηση  mergesort για να ταξινομήσουμε τον πίνακα Α κατα αλφαβητική σειρά(Θ(nlogn))
    \item Στις επόμενες 2 γραμμές ο αλγόριθμος εξετάζει το σενάριο να έχουμε ταυτόχρονα ισοβαθμία 50\%\ 2 υποψήφιων.Αυτο συμβαίνει οταν αρχικα εχουμε αρτίο αριθμό ψήφων και οι πρωτες μισές ψήφοι του ταξινομημένου πίνακα ανήκουν στον ένα υποψήφιο και οι άλλες μισές στον αλλο ,ολο αυτο μοντελοποιείται με έναν βρόχο ελέγχου που απαιτεί πεπέρασμενο  χρόνο 0(1) αφου ειναι 4 έλεγχεει.
    \item  Στις γραμμες 6-10 ο αλγόριθμος αναζητεί αμα υπάρχει διάστημα μήκους $\frac{n}{2}$ που να υπάρχει ο ίδιος υποψήφιος  ελέγχοντας μονο το 1ο και το $\frac{n}{2}$+1 ψήφο εκμεταλεύονας το γεγονός οτι ο πίνακας Α είναι ταξινομημένος . Ο συνολίκος χρόνος που απαιτεί η συγκεκριμένη διαδικασία είναι Τ($\frac{n}{2}$) και ειναί γραμμική η προσπέλαση άρα Ο(n).
    \item  επειδή η γραμμές 6-10 δεν συνδέοναται με κάποια αναδρομική σχέση μεσα στην συνάρτηση merge η \textbf{συνολικη πολυπλοκότητα} του 2ου αλγορίθμου είναι nlogn +n και αρα \textbf{0(nlogn).}
    \item Aνακεφαλαιώνοντας ο αλγόριθμος αυτός σαφώς εμφανίζεται ποιο βελτιωμένος από τον πρώτο καθώς εχούμε ελλατώσει τις συγκρίσεις σε μεγάλο βαθμό με την βοήθεια του devide and conquer αλλά και πάλι εμφανίζονται αρκετές επαναλήψεις ανάγνωσης ψήφου .
\end{itemize}

\begin{itemize}
\item Ερώτημα 3
\end{itemize}

\begin{lstlisting}[mathescape]
function MajorityFinder3(A[1...n])
 majority_person = []
 HashMap T
 for(i = 1 to n)
 	if(T.search(A[i]) = = true)
 		T[A[i]] = T[A[i]] + 1
 	else 
 		T.put([A[i], 1)
 	if(T[A[i]] $\geq \lceil\frac{n}{2}\rceil$)
 		if(majority_person[1] = = null)
 			majority_person[1] = A[i]
 		else
 			majority_person[2] = A[i]
 return majority_person
\end{lstlisting}

\section*{Πρόβλημα 2}

\begin{itemize}
\item Ερώτημα 1
\end{itemize}

\lstset{frame=none}
\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Algorithm 1}]
Έστω πίνακας T με στοιχεία n θετικούς ακεραίους με εύρος [0,...,k] (k ακέραιος)
\begin{lstlisting}[mathescape]
 for i = 0,...,k do
	 H[i] = 0
 end for
 for j = 1,...,n do
	 H[T[j]] = H[T[j]] + 1
 end for
 for i = 1,...,k do
	 H[i] = H[i] + H[i - 1]
 end for
 for j = n,...,1 do
	 S[H[T[j]]] = T[j]
	 H[T[j]] = H[T[j]] -1
 end for
\end{lstlisting}
\end{tcolorbox}

\pagebreak
\texttt{Ανάλυση Αλγορίθμου} 
\begin{itemize}
\item Στα βήματα (1-3) δημιουργείται ο πίνακας H με k στοιχεία (δηλαδή  με μέγεθος ίσο με το εύρος των αριθμών) και αρχικοποιούνται όλα τα στοιχεία του με 0.

\item Στα βήματα (4-6) χρησιμοποιείται ο πίνακας H για να μετρήσει πόσες φορές εμφανίζεται κάθε αριθμός στη λίστα T. Συγκεκριμένα διατρέχει τη λίστα T και αυξάνει το μετρητή H[T[j]] κάθε φορά που συναντά ένα στοιχείο T[j].

\item Στα βήματα (7-9) εκτελεί μια σωρευτική καταμέτρηση, αθροίζει δηλαδή το H[i] με το προηγούμενό του το H[i - 1] ώστε κάθε στοιχείο του πίνακα H να αποθηκεύει το άθροισμα του στοιχείου αυτού με όλα τα προηγούμενά του. Έτσι τελικά το κάθε στοιχείο H[i] δείχνει πόσοι αριθμοί προηγούνται του αριθμού i δηλαδη του T[j].

\item Στα βήματα (10-13) δημιουργείται ο τελικός πίνακα S, ο οποίος θα περιέχει τα στοιχεία του πίνακα T ταξινομημένα. Συγκεκριμένα ξεκινάει από το τέλος του πίνακα T και τοποθετεί κάθε στοιχείο στη θέση που του αντιστοιχεί στον πίνακα S με βάση τον πίνακα καταμετρητών H. Στη συνέχεια μειώνει κατά 1 τον μετρητή του στοιχείου που τοποθέτησε.
\end{itemize}
Παρακάτω ακολουθεί ένα παράδειγμα με $n=9$ και $k=3$. Έστω ο πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
T & 3 & 2 & 2 & 1 & 3 & 0 & 0 & 2 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}
Μετά τα βήματα (1-3) ο πίνακας H είναι ο εξής:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 0 & 0 & 0 & 0 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (4-6) ο πίνακας H έχει αποθηκεύσει πόσες φορές εμφανίζονται οι αριθμοί του πίνακα T:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 1 & 3 & 3 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (7-9) ο πίνακας H έχει αποθηκεύσει τα σωρευτικά αθροίσματα:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 3 & 6 & 9 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (10-13) ο πίνακας S που προκύπτει είναι ο ταξινομημένος πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
S & 0 & 0 & 1 & 2 & 2 & 2 & 3 & 3 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}











\pagebreak

Ερώτημα 2

\begin{tabular}{|l|c|c|}
\hline
Εντολές & costs (c) & times (t) \\\hline
1  for i = 0,...,k do   & c1 & k+2\\\hline
2  H[i] = 0 & c2 & k+1 \\\hline
3  end for & & \\\hline
4  for j=1,...,n do & c3 & n+1 \\\hline 
5 H[T[j]] = H[T[j]]+1 & c4 & n  \\\hline
6 end for &  & \\\hline
7 for i =1,...,k do & c5 & k+1   \\\hline
8 H[i]= H[i]+H[i-1] & c6 & k \\\hline
9 end for & &   \\\hline 
10 for j = n,...,1 do & c7 & n+1 \\\hline
11 S[H[T[ j ] ] ] = T[ j ] & c8 & n \\\hline
12 H[T[ j ] ] = H[T[ j ] ]-1 & c9 & n \\\hline
13 end for & &  \\\hline
\end{tabular}

\begin{align*}
T(n)&= \sum_{a=1}^{9} c_a\cdot t_a =  c_1\cdot (k+2) + c_2\cdot (k+1) + c_3\cdot (n+1) + c_4\cdot n + c_5\cdot (k+1) + c_6\cdot k \\
    &+ c_7\cdot (n+1) + c_8\cdot n + c_9\cdot n \implies \\\\
&\text{Όπου οι $c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9$ είναι κάποιες σταθερές}\\\\
\implies T(n)&= \mathcal{O}(n+k)
\end{align*}







\end{document}
