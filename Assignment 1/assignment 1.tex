\documentclass[a4paper, fleqn]{article}

\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath, mathtools}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 1}}

\author{Καζγκούτης Αθανάσιος \and
	    Charbel Al Haddad \and 
	    Παπαδόπουλος Δημήτριος-Λάζαρος
}

\date{March 24, 2023}

\begin{document}

\maketitle
\pagebreak
\section*{Πρόβλημα 1}

\textbf{
\color{red}Ερώτημα 1}
O αλγόριθμος που παρατιίθεται παρακάτω δέχεται σαν είσοδο μια συστοιχία n στοιχίων όπου n είναι οι ψήφοι -σε ονοματεπώνυμα-μιας κοινότητας.
Στόχος του αλγόριθμου ειναι:
\begin{enumerate}
    \item να ελέγξει ποιος υποψήφιος έχει τους περισσότερους ψήφους.
    \item αμα ξεπερνάει το 50\%\ των συνολικών ψήφων.
    \item εφόσων ισχύει το παραπάνω να επιστρέψει στην έξοδο το ονοματεπώνυμο του υποψήφιου .
  
\end{enumerate}
        $$ \textbf{ΑΛΓΟΡΙΘΜΟΣ 1}$$


\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}

\begin{lstlisting}[mathescape]
function MajorityFinder(A[1...n])
 majority_person
 maxcount = 0
 count
candidate
 for(i = 1 to n){
 	count = 0
 	candidate = A[i]
 	for(j = 1 to n){
 		if(candidate = = A[j])
 			count++}
 	if(count > maxcount)
 		maxcount = count
 		majority_person = temp}
 if(maxcount > $\lceil\frac{n}{2}\rceil$)
 	return majority_person
 else 
 	return "no person has the majority"
\end{lstlisting}
\textit{
\section*{
\subsection*{ΑΝΑΛΥΣΗ ΑΛΓΓΟΡΙΘΜΟΥ:}}
}

\begin{itemize}
    \item Στη $1^η$ σείρα ο αλγόριθμος δέχεται τις n ψήφους μέσω μιας συστοιχίας "A[1...n]"

    \item Στις γραμμές 2-5 γίνονται αρχικοποιήσεις μεταβλητών που χρησιμέυουν στη καταμέτρηση των ψήφων (count,maxcount) και των υποψήφιων(candidate,majority-person),ώστε να εξαχθεί το αποτέλεσμα με επιτυχία.

    \item Στις γραμμές 6-11 ο αλγόριθμος καταμετρεί όλες τις ψήφους κάθε υποψήφιου..Συγκεκριμένα η αρχική η for χρησιμοποιείται για να προσπελαστούν όλες οι ψήφοι,ενώ η 2η για να γίνει έλεγχος ποιες ψηφοί έχουν το ίδιο ονοματεπώνυμο με την i-στη.Η μεταβλητή  count απαριθμεί τις συνολικες ψήφους που έχει ο υποψήφιος της i-στης θέσης του αρχικού πινακα. Επίσης στη μεταβλητή candidate αποθηκέυται το ονοματεπώνυμο του υποψήφιου της i-στης ψήφου.Επειδή έχουμε εμφωλευμένες for η πολυπολοκότητα γίνεται Ο($n^2$).Τέλος να αναφέρουμε οτι ο ελέγχος που γίνεται στη γραμμη 10 είναι γραμμικός με Ο(κ) οπού κ το μήκος της συμβολοσειράς ,αλλα γίνεται εύκολα αντιληπτό πως η τάξη μεγέθους n$\gg$ κ οπότε ο ελέγχος κάθε συμβολοσείρας  θα θεωρείτε οτί έχει πολυπλοκότητα Ο(1).

    \item Στις γραμμες 12-14 γίνεται  ελεγχός για να βρέθει  ποιος υποψήφιος εχει τις περισσοτερες ψήφους.

    \item Στις τελευταιες γραμμες 15-18 σκοπός του αλγορίθμου είναι να ελεγχθεί αμά ο υποψήφιος που έχει τις περισσότερες ψήφους έχει επίσης και την πλειοψηφία(ποσοστό>50\%).

    \item Aνακεφαλαιώνοντας πρόκειται για έναν\textit{\textbf{ αργό αλγόριθμο Ο($n^2$)}}, καθώς ελέγχονται n φορες όλα τα ονοματεπώνυμα ενώ συγκρίνουμε ολές τις ψήφους μεταξύ τους μια προς μια n φορές .Γεγονώς που θα προσπαθήσουμε να ανατρέψουμε στα επώμενα ερωτήματα χρησιμοποιόντας καλύτερες τεχνικές.  
\end{itemize}
\newpage

\textbf{
\color{red}Ερώτημα 2}
Στη προσπάθεια μας να βελτιώσουμε τον αλγόριθμο πολυπλoκότητας από 0($n^2$) σε 0($logn$) θα χρησιμοποιήσουμε την στρατιγική \textit{\textbf{διαίρει-και-κυρίευε}}(Divide-and-conquer).Συγκεκριμένα ο αλγόριθμος  μας βασίζεται στην συγχωνευτική ταξινόμιση (merge sort) ,ωστε να ταξινομηθουν τα ονοματεπώνυμα σε μια σειρά(στη περίπτωση μας αλφαβητικά).Τελός έχωντας μια ταξινομημένη λίστα μπορούμε πολυ ευκόλα να ελέγξουμε αν υπάρχει υποψήφιος με τουλάχιστον 50\%\ των ψήφων όπως παρουσιάζεται  αναλυτικότερα παρακάτω. 



         \title{ο βοηθητικός αλγοριθμος που θα χρησιμοποιήσουμε:}
         


\lstset{frame=none}

\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Merge Sort}]
\begin{lstlisting}[mathescape]
function mergesort(a[1...n])
 if(n > 1)
 	return merge(mergesort(a[1...$\lfloor\frac{n}{2}\rfloor$]), mergesort(a[$\lfloor\frac{n}{2}\rfloor$ + 1 ...n]))
 else
 	return a
\end{lstlisting}

\begin{lstlisting}[mathescape]
function merge(x[1...k], y[1...l])
 if(k = 0)
 	return y[1...l]
 if(l = 0)
 	return x[1...l]
 if(x[1] $\geq$ y[1])
 	return x[1] $\circ$ merge(x[2...k], y[1...l])
 else
 	return y[1] $\circ$ merge(x[1...k], y[2...l])
\end{lstlisting}
\end{tcolorbox}

\subsection*{Ανάλυση merge sort για την περίπτωηση μας:}
\begin{itemize}
    \item \textbf{Αναδρομή}:διαιρούμε το πρόβλημα μας στη μέση $\frac{n}{2}$ διαδοχικά(a=2,b=2),η αναδρομή εξαντλείτε  οταν η ταξινομητέα ακολουθία έχει μήκος 1 $\geq$n, δηλαδή εχεί μονο μια ψήφο με ονοματεπώνυμο που ειναι ήδη ταξινομιμένη . 
\end{itemize}
    \begin{itemize}
        \item \textbf{Συγχώνευση(merge)}:η συνάρτηση αυτή συγχωνέυει ταξινομόντας 2 ήδη ταξινομημένους πίνακες ,το βασίκο βήμα της συνάστησης εκτελείτε το πολύ n φορές ενω το υπολογιστικό κοστός c ειναι στη χειρότερη περίπτωση  ίσο με το χρόνο που χρειάζεται να προσπελαστή ένα ονοματεπώνυμο ,αυτό συμβαίνει οταν έχουμε να συγκρίνουμε το ίδιο όνομα δηλαδή την ίδια ψήφο .Συγκεκρίμενα  πάλι θεώρουμε ότι το μήκος του έχει ενα λογικό εύρος και το c είναι απλα ένας πεπερασμένος αριθμός.Σε κάθε άλλη κατάσταση άν ο πρώτος χαρακτήρας από την πρώτη συμβολοσειρά είναι μεγαλύτερος (ή μικρότερος) από αυτόν της άλλης συμβολοσειράς, τότε η πρώτη συμβολοσειρά είναι μεγαλύτερη (ή μικρότερη) από τη δεύτερη.Σύμφωνα με τα παραπάνω η συνάρτηση merge έχει χρόνο εκτέλεσης \textbf{Θ(n)}.
    \end{itemize}
     \begin{itemize}
         \item \textbf{Συνολικός χρόνος} :Οπως  γνωρίζουμε απο την θεωρία (master theory) για a=2,b=2  $$Τ(n)=2T(\frac{n}{2})+Θ(n)=cnlogn+cn$$ αρα θα έχουμε χρόνο εκτέλεσης Θ(nlogn).
     \end{itemize}
\newpage
\begin{itemize}
    \item  παρακάτω παρουσιάζεται ο  βασικός αλγόριθμος του ερωτήματος 2 : 
             
\end{itemize}

          $$ \textbf{ΑΛΓΟΡΙΘΜΟΣ 2}$$

\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}


%θυμησου να πεις οτι ο πινακας ξεκιναει απο το 1 και οχι απο το 0
\begin{lstlisting}[mathescape]
function MajorityFinder2(A[1...n])
 mergesort(A)
 for(i = 1 to n){
     if((n mod 2 == 1) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$ - 1 + i)))		
                return A[i] //end algorithm
      if ((n mod 2 == 0) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$  + i)))
                 return A[i]//end algorithm
 }
 return no majority person found
 
  
\end{lstlisting}
\paragraph{    ΑΝΑΛΥΣΗ ΑΛΓΟΡΙΘΜΟΥ}
\begin{itemize}
    \item Στη πρωτη σειρα ο πίνακας Α δέχεται τους ψηφούς σε ονοματεπώνυμα (συμβολοσειρές).
\end{itemize}
\begin{itemize}
    \item Στη 2η γραμμή καλούμε την συνάρτηση  mergesort για να ταξινομήσουμε τον πίνακα Α κατα αλφαβητική σειρά(Θ(nlogn))
    \item Στις επόμενες 2 γραμμές ο αλγόριθμος εξετάζει το σενάριο να έχουμε ταυτόχρονα ισοβαθμία 50\%\ 2 υποψήφιων.Αυτο συμβαίνει οταν αρχικα εχουμε αρτίο αριθμό ψήφων και οι πρωτες μισές ψήφοι του ταξινομημένου πίνακα ανήκουν στον ένα υποψήφιο και οι άλλες μισές στον αλλο ,ολο αυτο μοντελοποιείται με έναν βρόχο ελέγχου που απαιτεί πεπέρασμενο  χρόνο 0(1) αφου ειναι 4 έλεγχεει.
    \item  Στις γραμμες 6-10 ο αλγόριθμος αναζητεί αμα υπάρχει διάστημα μήκους $\frac{n}{2}$ που να υπάρχει ο ίδιος υποψήφιος  ελέγχοντας μονο το 1ο και το $\frac{n}{2}$+1 ψήφο εκμεταλεύονας το γεγονός οτι ο πίνακας Α είναι ταξινομημένος . Ο συνολίκος χρόνος που απαιτεί η συγκεκριμένη διαδικασία είναι Τ($\frac{n}{2}$) και ειναί γραμμική η προσπέλαση άρα Ο(n).
    \item  επειδή η γραμμές 6-10 δεν συνδέοναται με κάποια αναδρομική σχέση μεσα στην συνάρτηση merge η \textbf{συνολικη πολυπλοκότητα} του 2ου αλγορίθμου είναι nlogn +n και αρα \textbf{0(nlogn).}
    \item Aνακεφαλαιώνοντας ο αλγόριθμος αυτός σαφώς εμφανίζεται ποιο βελτιωμένος από τον πρώτο καθώς εχούμε ελλατώσει τις συγκρίσεις σε μεγάλο βαθμό με την βοήθεια του devide and conquer αλλά και πάλι εμφανίζονται αρκετές επαναλήψεις ανάγνωσης ψήφου .
\end{itemize}

\begin{itemize}
\item Ερώτημα 3
\end{itemize}

\begin{lstlisting}[mathescape]
function MajorityFinder3(A[1...n])
 majority_person = []
 HashMap T
 for(i = 1 to n)
 	if(T.search(A[i]) = = true)
 		T[A[i]] = T[A[i]] + 1
 	else 
 		T.put([A[i], 1)
 	if(T[A[i]] $\geq \lceil\frac{n}{2}\rceil$)
 		if(majority_person[1] = = null)
 			majority_person[1] = A[i]
 		else
 			majority_person[2] = A[i]
 return majority_person
\end{lstlisting}

\section*{Πρόβλημα 2}

\begin{itemize}
\item Ερώτημα 1
\end{itemize}

\lstset{frame=none}
\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Algorithm 1}]
Έστω πίνακας T με στοιχεία n θετικούς ακεραίους με εύρος [0,...,k] (k ακέραιος)
\begin{lstlisting}[mathescape]
 for i = 0,...,k do
	 H[i] = 0
 end for
 for j = 1,...,n do
	 H[T[j]] = H[T[j]] + 1
 end for
 for i = 1,...,k do
	 H[i] = H[i] + H[i - 1]
 end for
 for j = n,...,1 do
	 S[H[T[j]]] = T[j]
	 H[T[j]] = H[T[j]] -1
 end for
\end{lstlisting}
\end{tcolorbox}

\pagebreak
\texttt{Ανάλυση Αλγορίθμου} 
\begin{itemize}
\item Στα βήματα (1-3) δημιουργείται ο πίνακας H με k στοιχεία (δηλαδή  με μέγεθος ίσο με το εύρος των αριθμών) και αρχικοποιούνται όλα τα στοιχεία του με 0.

\item Στα βήματα (4-6) χρησιμοποιείται ο πίνακας H για να μετρήσει πόσες φορές εμφανίζεται κάθε αριθμός στη λίστα T. Συγκεκριμένα διατρέχει τη λίστα T και αυξάνει το μετρητή H[T[j]] κάθε φορά που συναντά ένα στοιχείο T[j].

\item Στα βήματα (7-9) εκτελεί μια σωρευτική καταμέτρηση, αθροίζει δηλαδή το H[i] με το προηγούμενό του το H[i - 1] ώστε κάθε στοιχείο του πίνακα H να αποθηκεύει το άθροισμα του στοιχείου αυτού με όλα τα προηγούμενά του. Έτσι τελικά το κάθε στοιχείο H[i] δείχνει πόσοι αριθμοί προηγούνται του αριθμού i δηλαδη του T[j].

\item Στα βήματα (10-13) δημιουργείται ο τελικός πίνακα S, ο οποίος θα περιέχει τα στοιχεία του πίνακα T ταξινομημένα. Συγκεκριμένα ξεκινάει από το τέλος του πίνακα T και τοποθετεί κάθε στοιχείο στη θέση που του αντιστοιχεί στον πίνακα S με βάση τον πίνακα καταμετρητών H. Στη συνέχεια μειώνει κατά 1 τον μετρητή του στοιχείου που τοποθέτησε.
\end{itemize}
Παρακάτω ακολουθεί ένα παράδειγμα με $n=9$ και $k=3$. Έστω ο πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
T & 3 & 2 & 2 & 1 & 3 & 0 & 0 & 2 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}
Μετά τα βήματα (1-3) ο πίνακας H είναι ο εξής:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 0 & 0 & 0 & 0 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (4-6) ο πίνακας H έχει αποθηκεύσει πόσες φορές εμφανίζονται οι αριθμοί του πίνακα T:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 1 & 3 & 3 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (7-9) ο πίνακας H έχει αποθηκεύσει τα σωρευτικά αθροίσματα:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 3 & 6 & 9 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (10-13) ο πίνακας S που προκύπτει είναι ο ταξινομημένος πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
S & 0 & 0 & 1 & 2 & 2 & 2 & 3 & 3 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}











\pagebreak

Ερώτημα 2

\begin{tabular}{|l|c|c|}
\hline
Εντολές & costs (c) & times (t) \\\hline
1  for i = 0,...,k do   & c1 & k+2\\\hline
2  H[i] = 0 & c2 & k+1 \\\hline
3  end for & & \\\hline
4  for j=1,...,n do & c3 & n+1 \\\hline 
5 H[T[j]] = H[T[j]]+1 & c4 & n  \\\hline
6 end for &  & \\\hline
7 for i =1,...,k do & c5 & k+1   \\\hline
8 H[i]= H[i]+H[i-1] & c6 & k \\\hline
9 end for & &   \\\hline 
10 for j = n,...,1 do & c7 & n+1 \\\hline
11 S[H[T[ j ] ] ] = T[ j ] & c8 & n \\\hline
12 H[T[ j ] ] = H[T[ j ] ]-1 & c9 & n \\\hline
13 end for & &  \\\hline
\end{tabular}

\begin{align*}
T(n)&= \sum_{a=1}^{9} c_a\cdot t_a =  c_1\cdot (k+2) + c_2\cdot (k+1) + c_3\cdot (n+1) + c_4\cdot n + c_5\cdot (k+1) + c_6\cdot k \\
    &+ c_7\cdot (n+1) + c_8\cdot n + c_9\cdot n \implies \\\\
&\text{Όπου οι $c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9$ είναι κάποιες σταθερές}\\\\
\implies T(n)&= \mathcal{O}(n+k)
\end{align*}







\end{document}
