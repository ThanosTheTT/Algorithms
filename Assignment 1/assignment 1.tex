\documentclass[a4paper]{article}

\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{geometry}
\usepackage{amsmath, mathtools}
\usepackage[bottom, symbol]{footmisc}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\listsetup}
{\lstset{ 
  backgroundcolor=\color{blue!8!white},
  breaklines=true,
  commentstyle=\color{ForestGreen},
  frame=single,
  keywordstyle=\color{blue},
  language=C,
  numbers=left,
  numbersep=4pt,
  numberstyle=\color{black},
  rulecolor=\color{purple},    
  stringstyle=\color{orange},  
  showstringspaces=false,
  tabsize=4,
  framexleftmargin=14pt,
  framexrightmargin=0pt
}}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 1}}

\author{Καζγκούτης Αθανάσιος \and
	    Charbel Al Haddad \and 
	    Παπαδόπουλος Δημήτριος-Λάζαρος
}

\date{March 24, 2023}

\begin{document}
\maketitle
\pagebreak

\section*{Πρόβλημα 1}
\subsection*{\color{red}Ερώτημα 1}

O αλγόριθμος που παρατιίθεται παρακάτω δέχεται σαν είσοδο μια συστοιχία n στοιχίων όπου n είναι οι ψήφοι -σε ονοματεπώνυμα-μιας κοινότητας.
Στόχος του αλγόριθμου ειναι:
\begin{enumerate}
\item να ελέγξει ποιος υποψήφιος έχει τους περισσότερους ψήφους.
\item αμα ξεπερνάει το 50\%\ των συνολικών ψήφων.
\item εφόσων ισχύει το παραπάνω να επιστρέψει στην έξοδο το ονοματεπώνυμο του υποψήφιου .
\end{enumerate}
  
\begin{center}
\textit{\textbf{ΑΛΓΟΡΙΘΜΟΣ 1}}
\end{center}

\listsetup
\begin{lstlisting}[mathescape]
function MajorityFinder(A[1...n])
 majority_person
 maxcount = 0
 count
 candidate
 for(i = 1 to n){
 	count = 0
 	candidate = A[i]
 	for(j = 1 to n){
 		if(candidate = = A[j])
 			count++}
 	if(count > maxcount)
 		maxcount = count
 		majority_person = temp}
 if(maxcount > $\lceil\frac{n}{2}\rceil$)
 	return majority_person
 else 
 	return "no person has the_majority"
\end{lstlisting}

\subsection*{Ανάλυση Αλγορίθμου:}

\begin{itemize}
\item Στη $1^η$ σείρα ο αλγόριθμος δέχεται τις n ψήφους μέσω μιας συστοιχίας "A[1...n]"
\item Στις γραμμές 2-5 γίνονται αρχικοποιήσεις μεταβλητών που χρησιμέυουν στη καταμέτρηση των ψήφων (count,maxcount) και των υποψήφιων(candidate,majority-person),ώστε να εξαχθεί το αποτέλεσμα με επιτυχία.
\item Στις γραμμές 6-11 ο αλγόριθμος καταμετρεί όλες τις ψήφους κάθε υποψήφιου..Συγκεκριμένα η αρχική η for χρησιμοποιείται για να προσπελαστούν όλες οι ψήφοι,ενώ η 2η για να γίνει έλεγχος ποιες ψηφοί έχουν το ίδιο ονοματεπώνυμο με την i-στη.Η μεταβλητή  count απαριθμεί τις συνολικες ψήφους που έχει ο υποψήφιος της i-στης θέσης του αρχικού πινακα. Επίσης στη μεταβλητή candidate αποθηκέυται το ονοματεπώνυμο του υποψήφιου της i-στης ψήφου.Επειδή έχουμε εμφωλευμένες for η πολυπολοκότητα γίνεται Ο($n^2$).Τέλος να αναφέρουμε οτι ο ελέγχος που γίνεται στη γραμμη 10 είναι γραμμικός με Ο(κ) οπού κ το μήκος της συμβολοσειράς ,αλλα γίνεται εύκολα αντιληπτό πως η τάξη μεγέθους n$\gg$ κ οπότε ο ελέγχος κάθε συμβολοσείρας  θα θεωρείτε οτί έχει πολυπλοκότητα Ο(1).
\item Στις γραμμες 12-14 γίνεται  ελεγχός για να βρέθει  ποιος υποψήφιος εχει τις περισσοτερες ψήφους.
\item Στις τελευταιες γραμμες 15-18 σκοπός του αλγορίθμου είναι να ελεγχθεί αμά ο υποψήφιος που έχει τις περισσότερες ψήφους έχει επίσης και την πλειοψηφία(ποσοστό$>$50\%).
\item Aνακεφαλαιώνοντας πρόκειται για έναν\textit{\textbf{ αργό αλγόριθμο Ο($n^2$)}}, καθώς ελέγχονται n φορες όλα τα ονοματεπώνυμα ενώ συγκρίνουμε ολές τις ψήφους μεταξύ τους μια προς μια n φορές .Γεγονώς που θα προσπαθήσουμε να ανατρέψουμε στα επώμενα ερωτήματα χρησιμοποιόντας καλύτερες τεχνικές.  
\end{itemize}
\newpage

\subsection*{\color{red}Ερώτημα 2}
Στη προσπάθεια μας να βελτιώσουμε τον αλγόριθμο πολυπλoκότητας από 0($n^2$) σε 0($logn$) θα χρησιμοποιήσουμε την στρατιγική \textit{\textbf{διαίρει-και-κυρίευε}}(Divide-and-conquer).Συγκεκριμένα ο αλγόριθμος  μας βασίζεται στην συγχωνευτική ταξινόμιση (merge sort) ,ωστε να ταξινομηθουν τα ονοματεπώνυμα σε μια σειρά(στη περίπτωση μας αλφαβητικά).Τελός έχωντας μια ταξινομημένη λίστα μπορούμε πολυ ευκόλα να ελέγξουμε αν υπάρχει υποψήφιος με τουλάχιστον 50\%\ των ψήφων όπως παρουσιάζεται  αναλυτικότερα παρακάτω. Ο βοηθητικός αλγοριθμος που θα χρησιμοποιήσουμε:
         
\lstset{
backgroundcolor=\color{blue!20!white},
frame=none
}

\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Merge Sort}]
\begin{lstlisting}[mathescape]
function mergesort(a[1...n])
 if(n > 1)
 	return merge(mergesort(a[1...$\lfloor\frac{n}{2}\rfloor$]), mergesort(a[$\lfloor\frac{n}{2}\rfloor$ + 1 ...n]))
 else
 	return a
\end{lstlisting}
\lstset{
firstnumber=6
}
\begin{lstlisting}[mathescape]
function merge(x[1...k], y[1...l])
 if(k = 0)
 	return y[1...l]
 if(l = 0)
 	return x[1...l]
 if(x[1] $\geq$ y[1])
 	return x[1] $\circ$ merge(x[2...k], y[1...l])
 else
 	return y[1] $\circ$ merge(x[1...k], y[2...l])
\end{lstlisting}
\end{tcolorbox}

\subsection*{Ανάλυση merge sort για την περίπτωηση μας:}
\begin{itemize}
\item\textbf{Αναδρομή}:διαιρούμε το πρόβλημα μας στη μέση $\frac{n}{2}$ διαδοχικά(a=2,b=2),η αναδρομή εξαντλείτε  οταν η ταξινομητέα ακολουθία έχει μήκος 1 $\geq$n, δηλαδή εχεί μονο μια ψήφο με ονοματεπώνυμο που ειναι ήδη ταξινομιμένη.
\item \textbf{Συγχώνευση(merge)}:η συνάρτηση αυτή συγχωνέυει ταξινομόντας 2 ήδη ταξινομημένους πίνακες .Το βασικό βήμα της συνάστησης εκτελείτε το πολύ n φορές ενώ το υπολογιστικό κοστός c ειναι στη χειρότερη περίπτωση  ίσο με το χρόνο που χρειάζεται να προσπελαστή ένα ονοματεπώνυμο .Αυτό συμβαίνει όταν έχουμε να συγκρίνουμε την ίδια συμβολοσειρά ,δηλαδή την ίδια ψήφο .Συγκεκρίμενα  πάλι θεωρούμε ότι το μήκος του έχει ενα λογικό εύρος και το c είναι απλά ένας πεπερασμένος αριθμός(ανάλυση 1.1).Σε κάθε άλλη κατάσταση άν ο πρώτος χαρακτήρας από την πρώτη συμβολοσειρά είναι μεγαλύτερος (ή μικρότερος) από αυτόν της άλλης συμβολοσειράς, τότε η πρώτη συμβολοσειρά είναι μεγαλύτερη (ή μικρότερη) από τη δεύτερη.Σύμφωνα με τα παραπάνω η συνάρτηση merge έχει χρόνο εκτέλεσης \textbf{$\mathcal{O}(cn)=\mathcal{O}(n)$}.
    \end{itemize}
         \textbf{Συνολικός χρόνος} :Οπως  γνωρίζουμε απο την θεωρία (master theory) για $a=2,b=2$  $$Τ(n)=2T(\frac{n}{2})+f(n)=2T(\frac{n}{2})+\mathcal{O}(n)$$,
         όπου f(n) =$\mathcal{O}(n)$ καθώς:
         \begin{enumerate}
             \item ο χρόνος που απαιτείται για να δημιουργηθούν τα υποπροβλήματα $\mathcal{O}(1)$.
             \item o χρόνος για να γίνει συγxώνευση (merge)ειναι $\mathcal{O}(n)$.
         \end{enumerate}
         
         Aρα d=1 οπότε επειδή $d=log_b{a}$ και 
         \begin{equation}
             T(n)=
            \left\{
             \begin{array}{lr}
                \mathcal{O}(n^d)  &    \text{if }  d>log_b{a}\\
                \mathcal{O}(n^dlog_b{n}) & \text{if }  d=log_b{a}\\
                \mathcal{O}(n^{log_b{a}}) &  \text{if }  d<log_b{a}
             \end{array}
          \right\}
         \end{equation}
         
         Θα έχουμε: 
          Τ(n)=$\mathcal{O}(nlogn)$.
\item  παρακάτω παρουσιάζεται ο  βασικός αλγόριθμος του ερωτήματος 2 : 
\end{itemize}

\pagebreak
\begin{center}
\textit{\textbf{ΑΛΓΟΡΙΘΜΟΣ 2}}
\end{center}

\listsetup
%θυμησου να πεις οτι ο πινακας ξεκιναει απο το 1 και οχι απο το 0
\begin{lstlisting}[mathescape]
function MajorityFinder2(A[1...n])
 mergesort(A)
 for(i = 1 to n){
     if((n mod 2 == 1) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$ - 1 + i)))		
                return A[i] //end algorithm
      if ((n mod 2 == 0) AND (A[i] = = A[$\lceil\frac{n}{2}\rceil$  + i)))
                 return A[i]//end algorithm
 }
 return no majority person found
\end{lstlisting}
\subsection*{Ανάλυση Αλγορίθμου}
\begin{itemize}
\item Στη πρωτη σειρα ο πίνακας Α δέχεται τους ψηφούς σε ονοματεπώνυμα (συμβολοσειρές).

    \item Στη 2η γραμμή καλούμε την συνάρτηση  mergesort για να ταξινομήσουμε τον πίνακα Α κατα αλφαβητική σειρά$\mathcal{O}(nlogn)$
    \item Στις επόμενες  γραμμές ο αλγόριθμος εξετάζει άμα υπάρχει  διάστημα μήκους μεγαλύτερο από τον μισό πίνακα($\frac{n}{2}$ για περιττό n  και  $\frac{n}{2}$+1 για άρτιο) που να είναι ο ίδιος υποψήφιος στο πρώτο και στο τελευταίο στοιχειό του διαστήματος αναζήτησης, εκμεταλευόμενοι  το γεγονός οτι ο πίνακας Α είναι ταξινομημένος . Η διαδικασία τερματίζει είτε όταν βρεθεί υποψήφιος με πλειοψηφία είτε όταν θά έχουν προσπελαστεί όλα τα δυνατά διαστήματα χώρις κάποιο επιθυμητό αποτέλεσμα. H συγκεκριμένη διαδικασία είναι γραμμική και  έχει πολυπλοκότηα $\mathcal{O}(cn)=\mathcal{O}(n)$.

\pagebreak
\subsection*{\color{red}Ερώτημα 3}
Στο ερώτημα 1 μετράμε την συχνότητα που εμφανίζεται κάθε υποψήφιος στην λίστα χρησιμοποιώντας εμφολευμένο βρόγχο και για αυτό πετυχαίνουμε χρόνο εκτέλεσης Ο(ν2).
Όμως αν αφαιρέσουμε τον εσωτερικό βρόγχο μπορούμε να πετύχουμε χρονο εκτέλεσης Ο(ν).
Η ιδέα είναι να χρησιμοποιήσουμε hashmap για να μετρήσουμε και να αποθηκεύσουμε την συχνότητα εμφάνισης του κάθε υποψηφίου. Το hashmap μας επιτρέπει την αναζήτηση του υποψηφίου και την είσοδο στοιχείων σε χρόνο Ο(1)\footnotemark[7].

\begin{center}
\textit{\textbf{ΑΛΓΟΡΙΘΜΟΣ 2}}
\end{center}

\begin{lstlisting}[mathescape]
function MajorityFinder3(A[1...n])
 HashMap T
 for(i = 1 to n)
 	if(T.search(A[i]) = = false)
 		T.put([A[i], 1)
 	else 
 		T[A[i]] = T[A[i]] + 1
 	if(T[A[i]] $> \lceil\frac{n}{2}\rceil$)
 		return A[i]
\end{lstlisting}

\subsection*{Ανάλυση Αλγορίθμου}
\begin{itemize}
\item Στο βήμα 2 δημιουργούμε μία μεταβλητή τύπου hashmap όπου η αποθήκευση γίνεται σε ζευγάρια key - value όπου key είναι ο υποψήφιος και value ο αριθμός εμφάνισης του στην λίστα.
\item Στα βήματα 3 - 9 διατρέχουμε την λίστα Α για να αναζητήσουμε τον υποψήφιο Α[i] στο hashmap.
\item Συγκεκριμένα στα βήματα 4-5 η εντολή T.search αναζητεί στο hashmap τον υποψήφιο Α[i] και αν δεν υπάρχει τον τοποθετεί με την εντολή T.put και τοποθετεί σαν value την συχνότητα εμφάνισης που είναι 1.
\item Στα βήματα 6-7 αν ο υποψήφιος Α[i] υπάρχει στο hashmap το value του συγκεκριμένου δηλαδή η συχότητα εμφάνισης του αυξάνεται κατά 1.
\item Τέλος στα βήματα 8-9 ελέγχουμε αν η συχότητα εμφάνισης του υποψηφίου Α[i] είναι μεγαλύτερη από 50\% τότε επιστρέφουμε το όνομα αυτού του υποψηφίου. 
\end{itemize}
Επειδή τόσο οι εντολές T.search και Τ.put για ένα hashmap τρέχουν σε O(1)\footnotemark[7] και χρησιμοποιούμε ένα βρόγχο που επαναλαμβάνεται (n) φορές, πετυχαίνουμε συνολικό χρόνο O(n).\footnotetext[7]{Για να ισχύει ότι η αναζήτηση και η τοποθέτηση του ονόματος(string) του υποψηφίου τρέχει σε χρόνο Ο(1) πρέπει να αποφεύγονται οι συγκρούσεις. Ο καλύτερος τρόπος για να αποφεύγονται οι συγκρούσεις είναι χρησιμοποιώντας μια καλή hash function η οποία κατανέμει τα ονόματα των υποψηφίων ομοιόμορφα στο hashmap.}

\pagebreak
\section*{Πρόβλημα 2}
\subsection*{\color{red}Ερώτημα 1}

\lstset{
backgroundcolor=\color{blue!20!white},
frame=none
}

\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Algorithm 1}]
Έστω πίνακας T με στοιχεία n θετικούς ακεραίους με εύρος [0,...,k] (k ακέραιος)
\begin{lstlisting}[mathescape]
 for i = 0,...,k do
	 H[i] = 0
 end for
 for j = 1,...,n do
	 H[T[j]] = H[T[j]] + 1
 end for
 for i = 1,...,k do
	 H[i] = H[i] + H[i - 1]
 end for
 for j = n,...,1 do
	 S[H[T[j]]] = T[j]
	 H[T[j]] = H[T[j]] -1
 end for
\end{lstlisting}
\end{tcolorbox}

\subsection*{Ανάλυση Αλγορίθμου}
\begin{itemize}
\item Στα βήματα (1-3) δημιουργείται ο πίνακας H με k στοιχεία (δηλαδή  με μέγεθος ίσο με το εύρος των αριθμών) και αρχικοποιούνται όλα τα στοιχεία του με 0.
\item Στα βήματα (4-6) χρησιμοποιείται ο πίνακας H για να μετρήσει πόσες φορές εμφανίζεται κάθε αριθμός στη λίστα T. Συγκεκριμένα διατρέχει τη λίστα T και αυξάνει το μετρητή H[T[j]] κάθε φορά που συναντά ένα στοιχείο T[j].
\item Στα βήματα (7-9) εκτελεί μια σωρευτική καταμέτρηση, αθροίζει δηλαδή το H[i] με το προηγούμενό του το H[i - 1] ώστε κάθε στοιχείο του πίνακα H να αποθηκεύει το άθροισμα του στοιχείου αυτού με όλα τα προηγούμενά του. Έτσι τελικά το κάθε στοιχείο H[i] δείχνει πόσοι αριθμοί προηγούνται του αριθμού i δηλαδη του T[j].
\item Στα βήματα (10-13) δημιουργείται ο τελικός πίνακα S, ο οποίος θα περιέχει τα στοιχεία του πίνακα T ταξινομημένα. Συγκεκριμένα ξεκινάει από το τέλος του πίνακα T και τοποθετεί κάθε στοιχείο στη θέση που του αντιστοιχεί στον πίνακα S με βάση τον πίνακα καταμετρητών H. Στη συνέχεια μειώνει κατά 1 τον μετρητή του στοιχείου που τοποθέτησε.
\end{itemize}

\pagebreak
Παρακάτω ακολουθεί ένα παράδειγμα με $n=9$ και $k=3$. Έστω ο πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
T & 3 & 2 & 2 & 1 & 3 & 0 & 0 & 2 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}
Μετά τα βήματα (1-3) ο πίνακας H είναι ο εξής:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 0 & 0 & 0 & 0 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (4-6) ο πίνακας H έχει αποθηκεύσει πόσες φορές εμφανίζονται οι αριθμοί του πίνακα T:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 1 & 3 & 3 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (7-9) ο πίνακας H έχει αποθηκεύσει τα σωρευτικά αθροίσματα:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 3 & 6 & 9 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (10-13) ο πίνακας S που προκύπτει είναι ο ταξινομημένος πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
S & 0 & 0 & 1 & 2 & 2 & 2 & 3 & 3 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}

\subsection*{\color{red}Ερώτημα 2}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\color{blue}Εντολές & \color{blue}costs (c) & \color{blue}times (t) \\\hline
1 \hspace{5pt}	for i = 0,...,k do   & c1 & k+2\\\hline
2 \hspace{5pt}	H[i] = 0 & c2 & k+1 \\\hline
3 \hspace{5pt}	end for & & \\\hline
4 \hspace{5pt}	for j=1,...,n do & c3 & n+1 \\\hline 
5 \hspace{5pt}	H[T[j]] = H[T[j]]+1 & c4 & n  \\\hline
6 \hspace{5pt}	end for &  & \\\hline
7 \hspace{5pt}	for i =1,...,k do & c5 & k+1   \\\hline
8 \hspace{5pt}	H[i]= H[i]+H[i-1] & c6 & k \\\hline
9 \hspace{5pt}	fend for & &   \\\hline 
10\hspace{3pt}  for j = n,...,1 do & c7 & n+1 \\\hline
11\hspace{3pt}	S[H[T[ j ] ] ] = T[ j ] & c8 & n \\\hline
12\hspace{3pt}	H[T[ j ] ] = H[T[ j ] ]-1 & c9 & n \\\hline
13\hspace{3pt}	end for & &  \\\hline
\end{tabular}
\end{center}

\begin{align*}
T(n)&= \sum_{a=1}^{9} c_a\cdot t_a =  c_1\cdot (k+2) + c_2\cdot (k+1) + c_3\cdot (n+1) + c_4\cdot n + c_5\cdot (k+1) + c_6\cdot k \\
    &+ c_7\cdot (n+1) + c_8\cdot n + c_9\cdot n \implies \\\\
&\text{Όπου οι $c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9$ είναι κάποιες σταθερές}\\\\
\implies T(n)&= \mathcal{O}(n+k)
\end{align*}

\end{document}
