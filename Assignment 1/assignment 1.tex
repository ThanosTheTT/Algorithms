\documentclass[a4paper, fleqn]{article}

\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath, mathtools}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 1}}

\author{Καζγκούτης Αθανάσιος \and
	    Charbel Al Haddad \and 
	    Παπαδόπουλος Δημήτριος-Λάζαρος
}

\date{March 24, 2023}

\begin{document}

\maketitle
\pagebreak
\section*{Πρόβλημα 1}

\textbf{
\color{red}Ερώτημα 1}
O αλγόριθμος που παρατιίθεται παρακάτω δέχεται σαν είσοδο μια συστοιχία n στοιχίων όπου n ειναι οι ψήφοι -σε ονοματεπώνυμα-μιας κοινότητας.
Στόχος του αλγόριθμου ειναι:
\begin{enumerate}
    \item να ελέγξει ποιος/α έχει τους περισσότερους ψήφους.
    \item αμα ξεπερνούν ή είναι ίσοι του 50\%\ των συνολικών ψήφων.
    \item εφόσων ισχύει το παραπάνω επιστρέψει στην έξοδο το ονοματεπώνυμο του υποψήφιου(ελέγχοντας το ακραίο σεναρίο να υπάρχουν 2 υποψήφιοι που ισοβαθμούν ΚΑΙ έχουν το 50\%\ των ψήφων) .
  
\end{enumerate}
        $$ \textbf{ΑΛΓΟΡΙΘΜΟΣ 1}$$


\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}

\begin{lstlisting}[mathescape]
function MajorityFinder(A[1...n])
 majority_person = [array of 2 elements]
 maxcount = 0
 count
 temp
 for(i = 1 to n)
 	count = 0
 	temp = A[i]
 	for(j = 1 to n)
 		if(temp = = A[j])
 			count++
 	if(count > maxcount)
 		maxcount = count
 		majority_person[1] = temp
 		majority_person[2] = null
 	else if((count = = maxcount) AND (temp $\neq$ majority_person[1]))
 		majority_person[2] = temp
 if(maxcount $\geq$ $\lceil\frac{n}{2}\rceil$)
 	return majority_person
 else 
 	return "no person has the majority"
\end{lstlisting}
\textit{
\section*{
\subsection*{ΑΝΑΛΥΣΗ ΑΛΓΓΟΡΙΘΜΟΥ:}}
}

\begin{itemize}
    \item Στη $1^η$ σείρα ο αλγόριθμος δέχεται τις n ψήφους μέσω μιας συστοιχίας "A[1...n]"

    \item Στη $2^η$ σειρα ορίζουμε τον πίνακα "majority\_person" στον οποίο θα αποθηκευτεί  το ονόμα του υπερέχoντα υποψήφιου , το μέγεθος του πίνακα έχει 2 θέσεις για να καλύπτει και την περίπτωση που 2 υποψήφιοι συγκεντρώνουν από 50\% ο καθένας.

    \item Στις γραμμές 3-5 γίνονται αρχικοποιήσεις που χρησιμέυουν στη καταμέτρηση των ψήφων και των υποψήφιων με τους περισσότερους.

    \item Στις γραμμές 6-11 ο αλγόριθμος καταμετρεί όλες τις ψήφους .Συγκεκριμένα η αρχική η for χρησιμοποιείται για να προσπελαστούν όλες οι ψήφοι,ενώ η 2η για να γίνει έλεγχος ποιες ψηφοί έχουν το ίδιο ονοματεπώνυμο με την i-στη.Ετσι μεσω το count μετράμε τις συνολικες ψήφους που έχει ο υποψήφιος που βρισκεταιο στην i-στη θεση του αρχικου πινακα ενώ στο temp αποθηκέυται το ονοματεπώνυμο του.Eπειδη εχουμε εμφωλευμενες for η πολυπολοκοτητα γινεται Ο($n^2$).   

    \item Στις γραμμες 12-17 γίνεται  ελεγχός για να βρέθει  ποιος υποψήφιος εχει τις περισσοτερες ψήφους,ενω καλυπτεται η περιπτωση της ισοβαθμιας υποψηφιων μεσω του μεταβλητου πινακα "majority person"

    \item Στις τελευταιες γραμμες 18-21 γινεται ελεγχος αμα καποιος υποψήφιος εχει $\geq$ του 50\%\ των ψηφών,η εξοδος ειτε θα εχει κανενα ενα ή ακομα και 2 ομνοματα στην ακραια περίπτωση που έχουμε 2 υποψηφιους με τις μισε ψηφους αμφοτεροι.

    \item Aνακεφαλαιώνοντας πρόκειται για εναν αργο αλγορίθμο Ο($n^2$) καθως ελεγχονται n φορες όλα τα ονοματεπώνυμα ενώ συγκρίνουμε ολές τις ψήφους μεταξύ τους μια προς μια .Γεγονώς που θα προσπαθήσουμε να ανατρέψουμε στα επώμενα ερωτήματα   
\end{itemize}


\textbf{
\color{red}Ερώτημα 2}


\lstset{frame=none}

\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Merge Sort}]
\begin{lstlisting}[mathescape]
function mergesort(a[1...n])
 if(n > 1)
 	return merge(mergesort(a[1...$\lfloor\frac{n}{2}\rfloor$]), mergesort(a[$\lfloor\frac{n}{2}\rfloor$ + 1 ...n]))
 else
 	return a
\end{lstlisting}

\begin{lstlisting}[mathescape]
function merge(x[1...k], y[1...l])
 if(k = 0)
 	return y[1...l]
 if(l = 0)
 	return x[1...l]
 if(x[1] $\geq$ y[1])
 	return x[1] $\circ$ merge(x[2...k], y[1...l])
 else
 	return y[1] $\circ$ merge(x[1...k], y[2...l])
\end{lstlisting}
\end{tcolorbox}

\lstset{numbers=left, numbersep=5pt,frame=single,  framexleftmargin=15pt}

\pagebreak

\begin{lstlisting}[mathescape]
function MajorityFinder2(A[1...n])
 majority_person = []
 mergesort(A)
 for(i = 1 to n)
 	if(A[i] = = A[$\lceil\frac{n}{2}\rceil$ - 1 + i])
 		if(majority_person[1] = = null)
 			majority_person[1] = A[i]
 		else
 			majority_person[2] = A[i]
 return majority_person
\end{lstlisting}

\begin{itemize}
\item Ερώτημα 3
\end{itemize}

\begin{lstlisting}[mathescape]
function MajorityFinder3(A[1...n])
 majority_person = []
 HashMap T
 for(i = 1 to n)
 	if(T.search(A[i]) = = true)
 		T[A[i]] = T[A[i]] + 1
 	else 
 		T.put([A[i], 1)
 	if(T[A[i]] $\geq \lceil\frac{n}{2}\rceil$)
 		if(majority_person[1] = = null)
 			majority_person[1] = A[i]
 		else
 			majority_person[2] = A[i]
 return majority_person
\end{lstlisting}

\section*{Πρόβλημα 2}

\begin{itemize}
\item Ερώτημα 1
\end{itemize}

\lstset{frame=none}
\begin{tcolorbox}[colback=blue!20!white,colframe=purple!60!white,title=\textbf{Algorithm 1}]
Έστω πίνακας T με στοιχεία n θετικούς ακεραίους με εύρος [0,...,k] (k ακέραιος)
\begin{lstlisting}[mathescape]
 for i = 0,...,k do
	 H[i] = 0
 end for
 for j = 1,...,n do
	 H[T[j]] = H[T[j]] + 1
 end for
 for i = 1,...,k do
	 H[i] = H[i] + H[i - 1]
 end for
 for j = n,...,1 do
	 S[H[T[j]]] = T[j]
	 H[T[j]] = H[T[j]] -1
 end for
\end{lstlisting}
\end{tcolorbox}

\pagebreak
\texttt{Ανάλυση Αλγορίθμου} 
\begin{itemize}
\item Στα βήματα (1-3) δημιουργείται ο πίνακας H με k στοιχεία (δηλαδή  με μέγεθος ίσο με το εύρος των αριθμών) και αρχικοποιούνται όλα τα στοιχεία του με 0.

\item Στα βήματα (4-6) χρησιμοποιείται ο πίνακας H για να μετρήσει πόσες φορές εμφανίζεται κάθε αριθμός στη λίστα T. Συγκεκριμένα διατρέχει τη λίστα T και αυξάνει το μετρητή H[T[j]] κάθε φορά που συναντά ένα στοιχείο T[j].

\item Στα βήματα (7-9) εκτελεί μια σωρευτική καταμέτρηση, αθροίζει δηλαδή το H[i] με το προηγούμενό του το H[i - 1] ώστε κάθε στοιχείο του πίνακα H να αποθηκεύει το άθροισμα του στοιχείου αυτού με όλα τα προηγούμενά του. Έτσι τελικά το κάθε στοιχείο H[i] δείχνει πόσοι αριθμοί προηγούνται του αριθμού i δηλαδη του T[j].

\item Στα βήματα (10-13) δημιουργείται ο τελικός πίνακα S, ο οποίος θα περιέχει τα στοιχεία του πίνακα T ταξινομημένα. Συγκεκριμένα ξεκινάει από το τέλος του πίνακα T και τοποθετεί κάθε στοιχείο στη θέση που του αντιστοιχεί στον πίνακα S με βάση τον πίνακα καταμετρητών H. Στη συνέχεια μειώνει κατά 1 τον μετρητή του στοιχείου που τοποθέτησε.
\end{itemize}
Παρακάτω ακολουθεί ένα παράδειγμα με $n=9$ και $k=3$. Έστω ο πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
T & 3 & 2 & 2 & 1 & 3 & 0 & 0 & 2 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}
Μετά τα βήματα (1-3) ο πίνακας H είναι ο εξής:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 0 & 0 & 0 & 0 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (4-6) ο πίνακας H έχει αποθηκεύσει πόσες φορές εμφανίζονται οι αριθμοί του πίνακα T:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 1 & 3 & 3 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (7-9) ο πίνακας H έχει αποθηκεύσει τα σωρευτικά αθροίσματα:
\begin{center}
\begin{tabular}{r|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} \\
\cline{2-5}
H & 2 & 3 & 6 & 9 \\
\cline{2-5}
\end{tabular}\par
\end{center}
Μετά τα βήματα (10-13) ο πίνακας S που προκύπτει είναι ο ταξινομημένος πίνακας T:
\begin{center}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|}
\multicolumn{1}{r}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \multicolumn{1}{c}{7} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{9}\\
\cline{2-10}
S & 0 & 0 & 1 & 2 & 2 & 2 & 3 & 3 & 3\\
\cline{2-10}
\end{tabular}\par
\end{center}











\pagebreak

Ερώτημα 2

\begin{tabular}{|l|c|c|}
\hline
Εντολές & costs (c) & times (t) \\\hline
1  for i = 0,...,k do   & c1 & k+2\\\hline
2  H[i] = 0 & c2 & k+1 \\\hline
3  end for & & \\\hline
4  for j=1,...,n do & c3 & n+1 \\\hline 
5 H[T[j]] = H[T[j]]+1 & c4 & n  \\\hline
6 end for &  & \\\hline
7 for i =1,...,k do & c5 & k+1   \\\hline
8 H[i]= H[i]+H[i-1] & c6 & k \\\hline
9 end for & &   \\\hline 
10 for j = n,...,1 do & c7 & n+1 \\\hline
11 S[H[T[ j ] ] ] = T[ j ] & c8 & n \\\hline
12 H[T[ j ] ] = H[T[ j ] ]-1 & c9 & n \\\hline
13 end for & &  \\\hline
\end{tabular}

\begin{align*}
T(n)&= \sum_{a=1}^{9} c_a\cdot t_a =  c_1\cdot (k+2) + c_2\cdot (k+1) + c_3\cdot (n+1) + c_4\cdot n + c_5\cdot (k+1) + c_6\cdot k \\
    &+ c_7\cdot (n+1) + c_8\cdot n + c_9\cdot n \implies \\\\
&\text{Όπου οι $c_1,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9$ είναι κάποιες σταθερές}\\\\
\implies T(n)&= \mathcal{O}(n+k)
\end{align*}







\end{document}