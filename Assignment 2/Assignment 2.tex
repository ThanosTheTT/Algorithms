\documentclass[a4paper,11pt]{article}

\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{geometry}
\usepackage{amsmath, mathtools}
\usepackage[bottom, symbol]{footmisc}
\usepackage{indentfirst}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\listsetup}
{\lstset{ 
  backgroundcolor=\color{blue!8!white},
  breaklines=true,
  commentstyle=\color{ForestGreen},
  frame=single,
  keywordstyle=\color{blue},
  language=C,
  numbers=left,
  numbersep=4pt,
  numberstyle=\color{black},
  rulecolor=\color{purple},    
  stringstyle=\color{orange},  
  showstringspaces=false,
  tabsize=4,
  framexleftmargin=14pt,
  framexrightmargin=0pt
}}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 2}}

\author{Καζγκούτης Αθανάσιος (10339) \and
	    Παπαδόπουλος Δημήτριος-Λάζαρος (10485) }

\begin{document}
\maketitle
\newpage
\listsetup

\section*{Πρόβλημα 1}

Η συνάρτηση MaxSuccessPath παίρνει για ορίσματα τον γράφο G = (V,E), το βάρος κάθε ακμής (p) το οποίο εκφράζει την πιθανότητα ότι ένα πακέτο το οποίο στέλνεται από τη μία συσκευή θα φτάσει στην άλλη χωρίς να χαθεί, τον αφετηριακό κόμβο (s) και τον κόμβο προορισμού (t).
Στην γραμμή 2 εκτελείται η απόδοση αρχικών τιμών.
Στην γραμμή 3 ο αλγόριθμος δημιουργεί ένα κενό σύνολο (D) στο οποίο θα εισάγει τους κόμβους των οποίων οι τελικές πιθανότητες από την αφετηρία (s) έχουν ήδη προσδιοριστεί.
Στην γραμμή 4 δημιουργούμε μία ουρά προτεραιότητας μεγίστου Q για τους κόμβους με κλειδιά τις τιμές των πεδίων p και ορίζουμε ως αρχικό περιεχόμενο το σύνολο των κόμβων.
Στην συνέχεια κάθε φορά που διατρέχεται ο βρόχος while στην γραμμή 6 αφαιρείται από την ουρά ένας κόμβος u που έχει την μέγιστη εκτίμηση πιθανότητας (u.p) και προστίθεται στο σύνολο (D) στην γραμμή 9. Στις γραμμές 10-11 ο αλγόριθμος χαλαρώνει όλες τις ακμές (u,v) που εκκινούν από τον u. Στην γραμμή 7-8 ελέγχουμε αν ο κόμβος που βγήκε από την Q και άρα έχει προσδιοριστεί η τελική του πιθανότητα είναι ο κόμβος προορισμού (t), ώστε να τυπώσουμε την διαδρομή s$\rightarrow$t.

\begin{lstlisting}[mathescape]
function MaxSuccessPath(G,p,s,t)
    Initialize(G,s)
    D = $\emptyset$
    Q = G.V
    while Q $\neq \emptyset$
        u = ExtractMaxQ
        if (u = = t)
            PrintPath(u)
        D = D $\cup$ {u}
        for each vertex v $\in$ G.Adj[u]
        	Relax(u,v,p)
\end{lstlisting}

Η συνάρτηση Initialize αποδίδει τις αρχικές τιμές, όπου μετά το κάλεσμά της κάθε κόμβος v δεν θα έχει προκάτοχο (v.π = NULL), η πιθανότητα του αφετηριακού κόμβου (s) θα είναι (s.p = 1) ενώ για όλους τους υπόλοιπους θα είναι ίση με το 0.

\begin{lstlisting}[mathescape]
function Initialize(G,s)
    for each vertex v $\in$ G.V
        v.p = 0
        v.$\pi$ = NULL
    s.p = 1
\end{lstlisting}

Η διαδικαίσα της Χαλάρωσης μίας ακμής (u,v) έχει ως εξής: ελέγχουμε εάν μπορούμε να βελτιώσουμε την μέγιστη πιθανότητα (p) της διαδρομής για τον κόμβο v διερχόμενοι μεσω του u. Στην περίπτωση που η διαδρομή με την μέγιστη πιθανότητα που έχει βρεθεί μέχρι στιγμής έως τον v μπορεί να βελτιωθεί διερχόμενοι από τον u, τότε ενημερώνουμε την εκτίμηση (v.p) και τον προκάτοχο (v.π). Το $p_{uv}$ είναι η πιθανότητα σωστης λήψης μυνήματος ανάμεσα στους κόμβους (u,v).

\begin{lstlisting}[mathescape]
function Relax(u,v,p)
    if ($v.p < u.p \cdot p_{uv}$)
        $v.p = u.p \cdot p_{uv}$
        $v.\pi = u$
\end{lstlisting}

\newpage

Η συνάρτηση printPath παίρνει για όρισμα τον κόμβο προορισμού $(u)$ για τον οποίο θα βρεί το μονοπάτι που οδηγεί σε αυτόν. Χρησιμοποιούμε τον πίνακα $R$ όπου θα αποθηκεύουμε τους κόμβους. Στην γραμμή 3 ο πρώτος κόμβος στον $R$ είναι ο κόμβος προορισμού και τρέχουμε την while μέχρι να βρούμε κόμβο που να μην έχει προκάτοχο δηλαδή να είναι ο αφετηριακός. Στην γραμμή 5 αποθηκεύουμε στον $R$ τον προκάτοχο του αντίστοιχου κόμβου και στην γραμμή 6 $u$ με τον προκάτοχο του ώστε να τρέξουμε το μονοπάτι ανάποδα. Τέλος στις γραμμές 8-9 τυπώνουμε το μονοπάτι ξεκινώντας από το τέλος του πίνακα $R$ για να είναι οι κόμβοι με την σωστή σειρά.

\begin{lstlisting}[mathescape]
function printPath(u)
    i = 1
    R[0] = u
    while $u.\pi \neq NULL$
        R[i] = $u.\pi $
        $u = u.\pi$
        i = i + 1 
    for j = i-1 : -1 : 0
        print $\rightarrow$ R[j]
\end{lstlisting}

\begin{itemize}
\item ΕΓΚΥΡΟΤΗΤΑ ΑΛΓΟΡΙΘΜΟΥ
\end{itemize}

Έχουμε υλοποιήσει μια παραλλαγή του αλγορίθμου Dijkstra που αναζητά το μέγιστο μονοπάτι μεταξύ δύο servers (άρα το γράφημά μας είναι συνδεδεμένο) σε ένα δίκτυο. Ενδιαφερόμαστε για την πιθανότητα επιτυχίας της αποστολής μηνυμάτων ανάμεσα στους servers, και αυτή η πιθανότητα αναπαρίσταται ως βάρη στις ακμές. Τα βάρη αυτά προκύπτουν από το γινόμενο των πιθανοτήτων ($0<p<1$) και χρησιμοποιούνται ως βάρη ακμών.
Καθώς η πιθανότητα  κινείται  ανάμεσα στο 0 και το 1 (άρα δεν έχουμε αρνητικά σταθμισμένες ακμές), είμαστε σίγουροι ότι θα βρούμε το μέγιστο μονοπάτι. Αυτό συμβαίνει επειδή εάν υπάρχει κάποιος  κύκλος (μη αρνητικός φυσικά) δεν μπορεί να αυξάνεται συνεχώς και ανεξέλεγκτα η πιθανότητα προς το $\infty$  όπου σε αυτή την περίπτωση είναι αδύνατον να βρεθεί το μέγιστο μονοπάτι.
 
\begin{itemize}
\item ΠΟΛΥΠΛΟΚΟΤΗΤΑ
\end{itemize}

Η λειτουργία Initialize(G, s) εκτελείται για κάθε κόμβο του γράφου, οπότε η πολυπλοκότητα της είναι $\mathcal{O}(V)$, όπου $V$ είναι ο αριθμός των κόμβων στο γράφο.

Η Relax ελέγχει και ενημερώνει την πιθανότητα επιτυχίας και τον προκάτοχο των κόμβων οπότε απαιτεί σταθερό χρόνο $\mathcal{O}(1)$.

Η PrintPath απαιτεί χρόνο $\mathcal{O}(V)$, γιατί στη χειρότερη περίπτωση το μονοπάτι s$\rightarrow$t θα περναεί απο όλους τους κόμβους.

Η ExtractMaxQ απαιτεί $\mathcal{O}(V)$ γιατί η Q είναι μία ουρά προτεραιότητας στην οποία για να βρούμε το μέγιστο στοιχείο πρέπει να την διατρέξουμε όλη.

Στην MaxSuccessPath:
Στην γραμμή 2 $\rightarrow$ $\mathcal{O}(V)$, στις 3-4 $\rightarrow$ $\mathcal{O}(1)$, ενώ στις γραμμές 5-9 $\rightarrow$ $\mathcal{O}(V^2)$ καθώς η while τρέχει $V$ φορές στο worst case scenario(μέχρι να αδειάσει όλη η ουρά) και σε κάθε επανάληψη της while προσπελαύνεται η συνάρτηση ΕxtractMaxQ $\rightarrow$ $\mathcal{O}(V)$, ενώ θα τρέξει μόνο μία φορά η PrintPath $\rightarrow$ $\mathcal{O}(V)$.
Στις γραμμές 10-11 $\rightarrow$ $\mathcal{O}(E)$ (ΣΩΡΕΥΤΙΚΟ ΑΘΡΟΙΣΜΑ)


Συνολικά {\color{red}$$T(n)=\mathcal{O}(V)+\mathcal{O}(1)+\mathcal{O}(1)+\mathcal{O}(V^2)+\mathcal{O}(V)+\mathcal{O}(E)=\mathcal{O}(V^2+E)=\mathcal{O}(V^2)$$} όπως και o dijkstra αφού η δομή δεδομένων που χρησιμοποιούμε για την προσπέλαση των κορυφών( ExtractMaxQ -ουρά προτεραιότητας μεγίστου ) έχει την ίδια πολυπλοκότητα με την προσπέλαση πίνακα.

\newpage

\section*{Πρόβλημα 2}

\begin{itemize}
\item\textbf{Το πρόβλημα}\\
Το πρόβλημα που πρέπει να λύσουμε είναι να βρούμε το μέγιστο προσδοκώμενο συνολικό κέρδος όταν έχουμε $(n)$ πιθανές τοποθεσίες.
\item\textbf{Τα υποπροβλήματα}\\
Θεωρούμε $P[i]$ είναι το μέγιστο προσδοκώμενο συνολικό κέρδος αν ανοίξουμε τα εστιατόρια από το σημείο $m_{1}$ μέχρι το $m_{i}$. Επομένως τα υποπροβλήματα είναι να βρούμε τα μέγιστα κέρδη για $\forall i \in [0,n]$. Όπου για $i = n, P[n]$ είναι η λύση στο πρόβλημα που αναζητάμε.
\item\textbf{Η βέλτιστη Υποδομή}\\
Αρχικά στην βασική περίπτωση αν $i = 0$ τότε δεν υπάρχει καμία τοποθεσία και το κέρδος είναι μηδέν $P[0] = 0$.
Στην συνέχεια αν το $i>0$ υπάρχουν δύο επιλογές
\begin{enumerate}
\item Να μην ανοίξουμε εστιατόριο στην τοποθεσία $i$\\
Τότε το μέγιστο κέρδος $P[i]$ θα είναι το μέγιστο κέρδος των προηγούμενων $i-1$ τοποθεσιών, δηλαδή $P[i]=P[i-1]$
\item Να ανοίξουμε εστιατόριο στην τοποθεσία $i$\\
Τότε το συνολικό κέρδος θα είναι το κέρδος από το άνοιγμα του εστιατορίου στην τοποθεσία $m_{i}$ δηλαδή το  $p_{i}$ σύν το μέγιστο κέρδος από τα εστιατόρια μέχρι την τοποθεσία $m_{d}$ δηλαδή $P[d]$ όπου $d$ είναι ο μεγαλύτερος δείκτης για τον οποίο ισχύει ότι $d<i$ και $m_{d} \leq m_{i}-k$ (επειδή δύο εστιατόρια πρέπει να απέχουν μεταξύ τους τουλάχιστον $k$ μέτρα).
Επομένως $P[i] = p_{i} + P[d]$
\end{enumerate}
\end{itemize}

\vspace{1cm}

Η συνάρτηση MaxProfit παίρνει για ορίσματα τις τοποθεσίες σε μέτρα απο την αρχή της Εγνατίας $(m)$ και τα προσδοκώμενα κέρδη κάθε τοποθεσίας $(p)$. Η for τρέχει $n$ φορές όπου για κάθε $i$ υπολογίζει ποιο κέρδος απο τις δύο επιλογές που αναλύσαμε στην βέλτιστη υποδομή είναι μεγαλύτερο και το αποθηκεύει στο $P[i]$  και τέλος επιστρέφει την λύση στο αρχικό πρόβλημά μας το $P[n]$.

\begin{lstlisting}[mathescape]
function MaxProfit(m,p)
	P[0] = 0
	for i=1 to n
		d = FindMaxIndex$-$d(i)
		P[i] = max{P[i-1], $p_{i}$ + P[d]}
	return P[n]
\end{lstlisting}

\vspace{1cm}

Η συνάρτηση FindMaxIndex$-$d βρίσκει τον μεγαλύτερο δείκτη για τον οποίο ισχύει ότι $d<i$ και $m_{d} \leq m_{i}-k$. Στις γραμμές 2-3 ελέγχει αν το $i=1$ γιατί τότε δεν υπάρχει προηγούμενος δείκτης και για αυτό επιστρέφει $0$ ώστε στην MaxProfit να χρησιμοποιήσει $P[d]=P[0]$. Στην while ελέγχει κάθε φορά αν η τοποθεσία με δείτη $d$ απέχει λιγότερο από $k$ μέτρα απο τον $i$ ώστε να μειώσει και άλλο τον δείκτη d μέχρι να βρεί τον μεγαλύτερο $d$ που να απέχει τουλάχστον $k$ μετρα απο τον $i$. Στις γραμμές 7-8 κάνει έναν επιπλέον έλεγχο αν το $d$ μειούμενο συνεχώς φτάσει στην τιμή $0$, να επιστρέψει 
$0$ για τον ίδιο λόγο με την παραπάνω if στις γραμμές 2-3. Η περίπτωση το $d$ να φτασει στο $0$ γίνεται αν οι τοποθεσίες των εστιατορίων είναι πολύ κοντά και μαζεμένες σε χώρο μικρότερο απο $k$ μέτρα.

\begin{lstlisting}[mathescape]
function FindMaxIndex$-$d(i)
	if(i=1)
		return 0
	d = i-1
	while($m_{d} \geq m_{i}-k$)
		d = d - 1
		if(d=0)
			return 0
	return d
\end{lstlisting}

\begin{itemize}
\item \textbf{Χρονική Πολυπλοκότητα}
\end{itemize}
\begin{enumerate}
\item Η αρχικοποίηση του $P[0] = 0$ χρειάζεται σταθερό χρόνο $\mathcal{O}(1)$.
\item Ο βρόγχος for επαναλαμβάνεται από το $1$ μέχρι το $n$. Μέσα στον βρόγχο ο κώδικας εκτελεί τις ακόλουθες λειτουργίες:
\begin{enumerate}
\item Στην γραμμή $4$ καλεί την συνάρτηση FindMaxIndex-d(i), περνώντας την τρέχον τιμή του $i$. Η χρονική πολυπλοκότητα θα αναλυθεί παρακάτω.
\item Η γραμμή 5 περιλαμβάνει βασικές αριθμητικές πράξεις και συγκρίσεις που χρειάζονται τυπικά σταθερό χρόνο $\mathcal{O}(1)$. Άρα μέσα στον βρόγχο θα τρέξει $n$ φορές και θα χρειαστεί συνολικά $\mathcal{O}(n)$
\end{enumerate}
\item Η επιστροφή του $P[n]$ χρειάζεται σταθερό χρόνο $\mathcal{O}(1)$.
\end{enumerate}

\textbf{Ανάλυση FindMaxIndex-d(i):}
\begin{enumerate}
\item Η συνθήκη if χρειάζεται σταθερό χρόνο $\mathcal{O}(1)$.
\item Η ανάθεση $d = i-1$ χρειάζεται σταθερό χρόνο $\mathcal{O}(1)$.
\item Ο βρόχος while επαναλαμβάνεται έως ότου η συνθήκη ($m_{d} \geq m_{i}-k$) δεν είναι πλέον αληθής. Ο αριθμός των επαναλήψεων εξαρτάται από την συγκεκριμένη τιμή του $i$ και τη δομή των δεδομένων. Στο χειρότερο σενάριο ο βρόχος μπορεί να επαναληφθεί έως και $i-1$ φορές. Επομένως στην χειρότερη περίπτωση η FindMaxIndex-d(i) μέσα στην for της MaxProfit θα τρέξει σωρευτικά $$1 + 2 + 3 + ... + n = \sum_{1} ^{n} n = \frac{n(n+1)}{2} $$
Άρα ο Αλγόριθμος έχει συνολικά χρονική πολυπλοκότητα $\mathcal{O}(n^2)$
\end{enumerate}

\end{document}