\documentclass[a4paper,11pt]{article}



\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{tikz, tcolorbox}
\usepackage{geometry}
\usepackage{amsmath, mathtools}
\usepackage[bottom, symbol]{footmisc}

\usepackage{xcolor}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\listsetup}
{\lstset{ 
  backgroundcolor=\color{blue!8!white},
  breaklines=true,
  commentstyle=\color{ForestGreen},
  frame=single,
  keywordstyle=\color{blue},
  language=C,
  numbers=left,
  numbersep=4pt,
  numberstyle=\color{black},
  rulecolor=\color{purple},    
  stringstyle=\color{orange},  
  showstringspaces=false,
  tabsize=4,
  framexleftmargin=14pt,
  framexrightmargin=0pt
}}

\newgeometry{top = 3cm,
			 bottom = 3cm, 
			 inner = 3cm,
			 outer = 2cm}
			 
\title{\textbf{Algorithms - Assignment 2}}

\author{Καζγκούτης Αθανάσιο(10339) \and
	    Παπαδόπουλος Δημήτριος-Λάζαρος (10485) }

\begin{document}
\maketitle
\newpage
\listsetup

\section*{Πρόβλημα 1}

Η συνάρτηση MaxSuccessPath παίρνει για ορίσματα τον γράφο G = (V,E), το βάρος κάθε ακμής (p) το οποίο εκφράζει την πιθανότητα ότι ένα πακέτο το οποίο στέλνεται από τη μία συσκευή θα φτάσει στην άλλη χωρίς να χαθεί, τον αφετηριακό κόμβο (s) και τον κόμβο προορισμού (t).
Στην γραμμή 2 εκτελείται η απόδοση αρχικών τιμών.
Στην γραμμή 3 ο αλγόριθμος δημιουργεί ένα κενό σύνολο (D) στο οποίο θα εισάγει τους κόμβους των οποίων οι τελικές πιθανότητες από την αφετηρία (s) έχουν ήδη προσδιοριστεί.
Στην γραμμή 4 δημιουργούμε μία ουρά προτεραιότητας μεγίστου Q για τους κόμβους με κλειδιά τις τιμές των πεδίων p και ορίζουμε ως αρχικό περιεχόμενο το σύνολο των κόμβων.
Στην συνέχεια κάθε φορά που διατρέχεται ο βρόχος while στην γραμμή 6 αφαιρείται από την ουρά ένας κόμβος u που έχει την μέγιστη εκτίμηση πιθανότητας (u.p) και προστίθεται στο σύνολο (D) στην γραμμή 9. Στις γραμμές 10-11 ο αλγόριθμος χαλαρώνει όλες τις ακμές (u,v) που εκκινούν από τον u. Στην γραμμή 7-8 ελέγχουμε αν ο κόμβος που βγήκε από την Q και άρα έχει προσδιοριστεί η τελική του πιθανότητα είναι ο κόμβος προορισμού (t), ώστε να τυπώσουμε την διαδρομή s$\rightarrow$t.

\begin{lstlisting}[mathescape]
function MaxSuccessPath(G,p,s,t)
    Initialize(G,s)
    D = $\emptyset$
    Q = G.V
    while Q $\neq \emptyset$
        u = ExtractMaxQ
        if (u = = t)
            PrintPath(u)
        D = D $\cup$ {u}
        for each vertex v $\in$ G.Adj[u]
        	Relax(u,v,p)
\end{lstlisting}

Η συνάρτηση Initialize αποδίδει τις αρχικές τιμές, όπου μετά το κάλεσμά της κάθε κόμβος v δεν θα έχει προκάτοχο (v.π = NULL), η πιθανότητα του αφετηριακού κόμβου (s) θα είναι (s.p = 1) ενώ για όλους τους υπόλοιπους θα είναι ίση με το 0.

\begin{lstlisting}[mathescape]
function Initialize(G,s)
    for each vertex v $\in$ G.V
        v.p = 0
        v.$\pi$ = NULL
    s.p = 1
\end{lstlisting}

Η διαδικαίσα της Χαλάρωσης μίας ακμής (u,v) έχει ως εξής: ελέγχουμε εάν μπορούμε να βελτιώσουμε την μέγιστη πιθανότητα (p) της διαδρομής για τον κόμβο v διερχόμενοι μεσω του u. Στην περίπτωση που η διαδρομή με την μέγιστη πιθανότητα που έχει βρεθεί μέχρι στιγμής έως τον v μπορεί να βελτιωθεί διερχόμενοι από τον u, τότε ενημερώνουμε την εκτίμηση (v.p) και τον προκάτοχο (v.π). Το $p_{uv}$ είναι η πιθανότητα σωστης λήψης μυνήματος ανάμεσα στους κόμβους (u,v).

\begin{lstlisting}[mathescape]
function Relax(u,v,p)
    if ($v.p < u.p \cdot p_{uv}$)
        $v.p = u.p \cdot p_{uv}$
        $v.\pi = u$
\end{lstlisting}

\newpage
Η συνάρτηση printPath παίρνει για όρισμα τον κόμβο προορισμού $(u)$ για τον οποίο θα βρεί το μονοπάτι που οδηγεί σε αυτόν. Χρησιμοποιούμε τον πίνακα $R$ όπου θα αποθηκεύουμε τους κόμβους. Στην γραμμή 3 ο πρώτος κόμβος στον $R$ είναι ο κόμβος προορισμού και τρέχουμε την while μέχρι να βρούμε κόμβο που να μην έχει προκάτοχο δηλαδή να είναι ο αφετηριακός. Στην γραμμή 5 αποθηκεύουμε στον $R$ τον προκάτοχο του αντίστοιχου κόμβου και στην γραμμή 6 $u$ με τον προκάτοχο του ώστε να τρέξουμε το μονοπάτι ανάποδα. Τέλος στις γραμμές 8-9 τυπώνουμε το μονοπάτι ξεκινώντας από το τέλος του πίνακα $R$ για να είναι οι κόμβοι με την σωστή σειρά.

\begin{lstlisting}[mathescape]
function printPath(u)
    i = 1
    R[0] = u
    while $u.\pi \neq NULL$
        R[i] = $u.\pi $
        $u = u.\pi$
        i = i + 1 
    for j = i-1 : -1 : 0
        print $\rightarrow$ R[j]
\end{lstlisting}

\begin{itemize}
\item ΕΓΚΥΡΟΤΗΤΑ ΑΛΓΟΡΙΘΜΟΥ
\end{itemize}


Έχουμε υλοποιήσει μια παραλλαγή του αλγορίθμου Dijkstra που αναζητά το μέγιστο μονοπάτι μεταξύ δύο servers(αρα το γραφημα μας ειναι συνδεδεμένο) σε ένα δίκτυο. Ενδιαφερόμαστε για την πιθανότητα επιτυχίας της αποστολής μηνυμάτων ανάμεσα στους servers, και αυτή η πιθανότητα αναπαρίσταται ως βάρη στις ακμές. Τα βάρη αυτά προκύπτουν από το γινόμενο των πιθανοτήτων ($0<p<1$) και χρησιμοποιούνται ως βάρη ακμών.

 Καθώς η πιθανότητα  κινείται  ανάμεσα στο 0 και το 1(άρα δεν έχουμε αρνητικά σταθμισμένες ακμές), είμαστε σίγουροι ότι θα βρούμε το μέγιστο μονοπάτι. Αυτό συμβαίνει επειδή εαν υπάρχει κάποιος  κύκλος(μη αρνητικός φυσικά) δεν μπορεί να αυξάνεται συνεχώς , ανεξέλεγκτα η πιθανότητα προς το $\infty$  όπου σε αυτή την περίπτωση αδυνατεί να  βρει το μέγιστο μονοπάτι.
 
 \begin{itemize}
\item ΠΟΛΥΠΛΟΚΟΤΗΤΑ
\end{itemize}

Η λειτουργία Initialize(G, s) εκτελείται για κάθε κόμβο του γράφου, οπότε η πολυπλοκότητα της είναι O(V), όπου V είναι ο αριθμός των κόμβων στο γράφο.
Relax: Ελέγχει και ενημερώνει την πιθανότητα επιτυχίας και τον προκάτοχο των κόμβων, απαιτεί σταθερό χρόνο O(1).
Εκτέλεση της PrintPath(u): Αυτή η λειτουργία απαιτεί χρόνο O(V), γιατί στη χειρότερη περίπτωση το μονοπάτι s$\rightarrow$t θα περναεί απο όλους τους κόμβους.
Η λειτουργία ExtractMaxQ απαιτεί O(V) γιατί η Q είναι μία ουρά προτεραιότητας στην οποία για να βρούμε το μεγιστο στοιχείο πρεπει να την διατρέξουμε όλη .

Στην MaxSuccessPath :
Στη γραμμη 2 Ο(V),
στις 3,4 Ο(1),ενώ
στις γραμμές 5-9 Ο($V^2$)καθως η while  τρέχει V φορές worst case scenario(μεχρι να αδειάσει ολη η ουρά) και σε κάθε επανάλυψη της while προσπελαύνεται η συνάρτηση ΕxtractMaxQ O(V) Ενω θα τρέξει μονο μια φορά η PrintPath O(V).
Στις γραμμες 10-11 Ο(Ε)(ΣΩΡΕΥΤΙΚΟ ΑΘΡΟΙΣΜΑ)
καθως εχούμε τη while που τρέχει V φορές και σε κάθε επανάλυψη της while

Συνολικά {\color{red}{Τ(n)=$\Sigma$cj=$O(V)$+$O(1)$+$O(1)$+$O(V^2)$+$O(V)$+$O(E)$=$O(V^2+E)$=$O(V^2)$}} όπως και dijkstra αφού η δομή δεδομένων που χρησιμοποιούμε για την προσπέλαση των server ειναι σε πίνακα\




 
\newpage
\section*{Πρόβλημα 2}

\begin{itemize}
\item\textbf{Το πρόβλημα}\\
Το πρόβλημα που πρέπει να λύσουμε είναι να βρούμε το μέγιστο προσδοκώμενο συνολικό κέρδος όταν έχουμε $(n)$ πιθανές τοποθεσίες.
\item\textbf{Τα υποπροβλήματα}\\
Θεωρούμε $P[i]$ είναι το μέγιστο προσδοκώμενο συνολικό κέρδος αν ανοίξουμε τα εστιατόρια από το σημείο $m_{1}$ μέχρι το $m_{i}$. Επομένως τα υποπροβλήματα είναι να βρούμε τα μέγιστα κέρδη για $\forall i \in [0,n]$. Όπου για $i = n, P[n]$ είναι η λύση στο πρόβλημα που αναζητάμε.
\item\textbf{Η βέλτιστη Υποδομή}\\
Αρχικά στην βασική περίπτωση αν $i = 0$ τότε δεν υπάρχει καμία τοποθεσία και το κέρδος είναι μηδέν $P[0] = 0$.
Στην συνέχεια αν το $i>0$ υπάρχουν δύο επιλογές
\begin{enumerate}
\item Να μην ανοίξουμε εστιατόριο στην τοποθεσία $i$\\
Τότε το μέγιστο κέρδος $P[i]$ θα είναι το μέγιστο κέρδος των προηγούμενων $i-1$ τοποθεσιών, δηλαδή $P[i]=P[i-1]$
\item Να ανοίξουμε εστιατόριο στην τοποθεσία $i$\\
Τότε το συνολικό κέρδος θα είναι το κέρδος από το άνοιγμα του εστιατορίου στην τοποθεσία $m_{i}$ δηλαδή το  $p_{i}$ σύν το μέγιστο κέρδος από τα εστιατόρια μέχρι την τοποθεσία $m_{d}$ δηλαδή $P[d]$ όπου $d$ είναι ο μεγαλύτερος δείκτης για τον οποίο ισχύει ότι $d<i$ και $m_{d} \leq m_{i}-k$ (επειδή δύο εστιατόρια πρέπει να απέχουν μεταξύ τους τουλάχιστον $k$ μέτρα).
Επομένως $P[i] = p_{i} + P[d]$
\end{enumerate}
\end{itemize}

Η συνάρτηση MaxProfit παίρνει για ορίσματα τις τοποθεσίες σε μέτρα απο την αρχή της Εγνατίας $(m)$ και τα προσδοκώμενα κέρδη κάθε τοποθεσίας $(p)$. Η for τρέχει $n$ φορές όπου για κάθε $i$ υπολογίζει ποιο κέρδος απο τις δύο επιλογές που αναλύσαμε στην βέλτιστη υποδομή είναι μεγαλύτερο και το αποθηκεύει στο $P[i]$  και τέλος επιστρέφει την λύση στο αρχικό πρόβλημά μας το $P[n]$.

\begin{lstlisting}[mathescape]
function MaxProfit(m,p)
	P[0] = 0
	for i=1 to n
		d = FindMaxIndex$-$d(i)
		P[i] = max{P[i-1], $p_{i}$ + P[d]}
	return P[n]
\end{lstlisting}

Η συνάρτηση FindMaxIndex$-$d βρίσκει τον μεγαλύτερο δείκτη για τον οποίο ισχύει ότι $d<i$ και $m_{d} \leq m_{i}-k$. Στις γραμμές 2-3 ελέγχει αν το $i=1$ γιατί τότε δεν υπάρχει προηγούμενος δείκτης και για αυτό επιστρέφει $0$ ώστε στην MaxProfit να χρησιμοποιήσει $P[d]=P[0]$. Στην while ελέγχει κάθε φορά αν η τοποθεσία με δείτη $d$ απέχει λιγότερο από $k$ μέτρα απο τον $i$ ώστε να μειώσει και άλλο τον δείκτη d μέχρι να βρεί τον μεγαλύτερο $d$ που να απέχει τουλάχστον $k$ μετρα απο τον $i$. Στις γραμμές 7-8 κάνει έναν επιπλέον έλεγχο αν το $d$ μειούμενο συνεχώς φτάσει στην τιμή $0$, να επιστρέψει 
$0$ για τον ίδιο λόγο με την παραπάνω if στις γραμμές 2-3. Η περίπτωση το $d$ να φτασει στο $0$ γίνεται αν οι τοποθεσίες των εστιατορίων είναι πολύ κοντά και μαζεμένες σε χώρο μικρότερο απο $k$ μέτρα.

\begin{lstlisting}[mathescape]
function FindMaxIndex$-$d(i)
	if(i=1)
		return 0
	d = i-1
	while($m_{d} \geq m_{i}-k$)
		d = d - 1
		if(d=0)
			return 0
	return d
\end{lstlisting}

\end{document}
